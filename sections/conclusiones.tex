\documentclass[../main.tex]{subfiles}

\begin{document}

\subsection{Conclusioness}
Tras estudiar los conceptos detrás de la Programación Funcional la principal
conclusión es que provee un cambio de mentalidad a la hora de implementar programas
respecto a los elementos sobre los que estos se construyen.

Los elementos sobre los que se construyen los programas imperativos son procedimientos
que modifican el estado global del programa. Estos procedimientos no se centran exclusivamente
en el valor que producen si no en el \textit{cómo} lo producen. Un procedimiento en programación
imperativa no tiene por que devolver un resultado para realizar algo constructivo en la aplicación.
Tan es así que en los lenguajes imperativos existe un tipo \textt{void} que puede declararse
como devuelto por las funciones que no devuelven un valor en sí, sino que modifican el estado global
como propósito.

Sin embargo en la programación funcional los bloques elementales son funciones. Estas
funciones se pueden ver como representaciones opacas del valor que devuelven. Por eso
mismo los elementos de programas funcionales se consideran declarativos más que imperativos.
Porque se centran en \texit{qué} valores devuelven, y no en \texttt{cómo} los devuelven.
Por eso mismo los programas funcionales se pueden considerar valores más que una serie de
instrucciones que modifican un estado global.

Al final, los programas funcionales que interactúan con el mundo real son descripciones de
las operaciones a realizar dentro del contexto de una Mónada IO \texttt{IO}. Esto se ha visto
a la hora de crear los bloques que formarían la aplicación que acompaña al documento. Por ejemplo
las funciones de Doobie devolvían un valor del tipo \texttt{ConnectionIO} que no eran más que
descripciones de los valores que se devolverían una vez que se le proveyese un \texttt{java.sql.Connection}.
Las rutas de Http4s eran una descripción de que hacer con una petición HTTP entrante, por lo que al
final los programas funcionales son descripciones estáticas de unas operaciones a realizar pero
no es hasta que el programa se interpreta que las operaciones finalmente se realizan.

Este cambio de paradigma realiza la premisa que se proponía en la introducción. Como las
funciones son meras descripciones del valor que devuelven en función de sus entradas, estas
pueden ser reusadas sin afectar a las operaciones que ya existen en la aplicación. Esto permite
que los cambios puedan ocurrir de manera más rápida, ya que el programador tiene que preocuparse
únicamente en producir nuevos valores, y no en si ha roto la funcionalidad existente.

Además, la Programación Funcional permite un nuevo modelo de razonamiento sobre los
programas. Dado que las funciones son descripciones de los valores que producen, el
programador no debe pensar en cómo van a afectar el contexto en el que sean llamadas a
las funciones en cuestión. Lo único que debe preocuparle es el valor que producen, y es
por ello que las funciones son más fáciles de producir y de entender. Este principio es
el que se presentó en el Capítulo 2 como ''Local Reasoning''.

Al mismo tiempo, el estudio de la programación reactiva ha proporcionado una serie de
características que los sistemas deben tener para responder eficientemente a los usuarios.
La Programación Funcional ha mostrado ser muy apropiada para construir Sistemas Reactivos, ya que ciertos elementos como el manejo explícito de los errores aumenta la resiliencia de
los programas, reduciendo la cantidad de errores que pueden no ser manejados.

La programación funcional también introduce un sistema de concurrencia muy seguro.
Con el tipo de datos \texttt{IO} es muy fácil representar operaciones que van a ser
procesadas en paralelo, y dado que los programas funcionales no dependen de estado
mutable compartido algunos problemas tales como una Condición de Secuencia o un Bloqueo
Mutuo no puedan ocurrir.

Finalmente el modelo de intercambio de mensajes de los Sistemas reactivos está bastante
alineado con el estilo de Programación Funcional, dado que los resultados de las funciones
son simplemente valores producidos por entradas inmutables que pueden considerarse mensajes.

Todo ello hace los Sistemas Funcionales y Reactivos apropiados para la demanda a las que
se enfrentan las aplicaciones de hoy en día, que no solo tienen que responder rápidamente
a las interacciones de los usuarios si no adaptarse a los cambios que estos demandan.

\subsection{Líneas Futuras}
Algunos de los conceptos que se han estudiado podrían explorarse en mas profundidad. A continuación
se presentan algunos temas que podrían ser estudiados como líneas futuras.


\paragraph{Programación Funcional y Teoría de Categorías}

Algunas categorías de Teoría de Categorías se han usado para combinar valores
en las aplicaciones, tales como las Mónadas o las Categorías de Kleisli. Un estudio
de los fundamentos de dichas categorías y su relación con la programación funcional
podría ayudar a escribir programas más expresivos, legítimos y concisos.

\paragraph{Desarrollo de un Sistema Funcional de Actores}

En el documento se ha desarrollado una implementación básica de un actor. Sin embargo
alguna de las características más avanzadas de algunos Sistemas de Actores como balanceo
de carga o Árboles de supervisión no se han podido implementar debido al tiempo que
requeriría. Una implementación que proveyese dichas características haría el uso de actores
más conveniente en el contexto de la Programación Funcional.

\paragraph{Sistemas Imperativos y Reactivos}
Este documento se ha centrado en el estudio de Sistemas Funcionales y Reactivos.
Aunque se hayan encontrado beneficios en la combinación de ambos, sería interesante
estudiar los Sistemas Reactivos dentro del paradigma imperativo, para poder compararlos con
sus contrapartes funcionales para elegir la opción más apropiada para cada escenario.

\end{document}